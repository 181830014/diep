<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="lib/jquery.min.js"> </script>
  <script src="lib/jcanvas.min.js"></script>
  <script src="lib/createjs.min.js"></script>
  <script src="lib/widget.js"></script>
  <script src="lib/vue.min.js"></script>
  <script type="text/javascript">
  	// 忽略ctrl+滚轮缩放事件
  	// others
	window.addEventListener('mousewheel', function(event) {
	    if (event.ctrlKey === true || event.metaKey) {
	          event.preventDefault();
	    }
	}, {passive: false});
	// firefox
	window.addEventListener('DOMMouseScroll', function(event) {
		if (event.ctrlKey === true || event.metaKey) {
		    event.preventDefault();
		}
	}, {passive: false}); 
  </script>
  <link rel="stylesheet" type="text/css" href="stylesheets/index_login.css">
</head>

<div id="login-page" class="login-page">
  <div class="input-cont">
    <input id="name-box" type="text" maxlength="30" v-on:keyup.13="login()" v-model="nickname" placeholder="input your name" />
    <div id="btn-start" class="btn-start" v-on:click="login()">
      <span>Start !</span>
      <div id="connecting-img" class="connecting-img" v-bind:class="{'show':gameState==1}"></div>
    </div>
  </div>
</div>

<body style="overflow:-Scroll; overflow-x:hidden; overflow-y:hidden; height:100%"> 
<canvas id="Hcanvas"></canvas>
<canvas id="canvas" height="2000" width="2000" style="background-color:gainsboro;"></canvas>
<script type="text/javascript" src="/socket.io/socket.io.js"></script>
<script>
  var pageVueData = {
    nickname: '',
    gameState: 0 // 0表示未开始 1表示等待连接 2表示游戏运行中
    // other attrs ...
  }
  var pageVue = new Vue({
    el: '#login-page',
    data: pageVueData,
    methods: {
      login: function () {
        if (pageVueData.gameState != 0) return;
        pageVueData.gameState = 1;
        // TODO:发送 pageVueData.nickname 给服务器
        // 默认5s后拒绝登录，应移除
        setTimeout('gameStart()', "5000");
      }
    }
  });
  // ------------以下是服务器拒绝登入后应触发的过程实例---------------
  function accessDenied() {
    pageVueData.nickname = '';
    pageVueData.gameState = 0;
  }
  // ------------以下是服务器准许登入后应触发的过程实例---------------
  function gameStart(nickname) {
    $('#login-page').remove();
    pageVueData.gameState = 2;
    alert(pageVueData.nickname);
  }

  var socket = io();

  var canvas = document.getElementById('canvas');
  var Hcanvas = document.getElementById('Hcanvas');

  var ctx = canvas.getContext('2d');
  var cvsBox = canvas.getBoundingClientRect();
  var stage = new createjs.Stage('canvas');
  const FRAME_RATE = 60;
  createjs.Ticker.framerate = FRAME_RATE;

  const BODY_WIDTH = window.innerWidth;
  const BODY_HEIGHT = window.innerHeight;

  const CANVAS_LEFT = 50;
  const CANVAS_BOTTOM = 50;
  const CANVAS_RIGHT = canvas.clientWidth - 50;
  const CANVAS_TOP = canvas.clientHeight - 50;
  const CANVAS_WIDTH = canvas.clientWidth;
  const CANVAS_HEIGHT = canvas.clientHeight;

  const STAGE_WIDTH = canvas.clientWidth + 80;     // TODO: change
  const STAGE_HEIGHT = canvas.clientHeight + 80;

  const MAX_PLAYER_NUMBER = 30;
  const MAX_TANK_GRADE = 30;
  const KEYBOARD_UP = 87;
  const KEYBOARD_DOWN = 83;
  const KEYBOARD_LEFT = 65;
  const KEYBOARD_RIGHT = 68;

  var KEYBOARD_CONDITION = 0;   // 0000 UP DOWN LEFT RIGHT
  var banKeyBoard = false;
  // tools
  var tools = {};

  tools.deg2Rad = function(deg) {
    return (deg % 360) * (Math.PI / 180);
  };

  tools.vec2Deg = function () {
    var radianToDegreesFactor = 180 / Math.PI;
    return function (x, y) {
      if (x == 0 && y == 0) {
        return 360;
      }
      rad = Math.atan(y / x);
      var result = rad * radianToDegreesFactor;
      if (x < 0) {
        result += 180;
      }
      if (result < 0) {
        result += 360;
      }
      return result;
    }
  }();


  var modelList = [];
  var tankList = [];
  var creepList = [];
  var bulletList = [];
  var tankMap = new Object();
  var creepMap = new Object();
  var bulletMap = new Object();

  var levelUpThreshold = [0];
  for(let i = 1; i <= 30; i++)
    levelUpThreshold.push(i * 100 + 500);

  // Global part
  function isNear(obj1, obj2) {
    if(obj1.armsId == obj2.armsId)
      return false;
    let x1 = obj1.model.x, y1 = obj1.model.y;
    let x2 = obj2.model.x, y2 = obj2.model.y;
    return Math.abs(y2 - y1) <= (STAGE_HEIGHT >> 1) &&
            Math.abs(x2 - x1) <= (STAGE_WIDTH >> 1);
  }

  function isCollided(obj1, obj2) {  // 判断两物块是否碰撞
    if(obj1.armsId == obj2.armsId)
      return false;
    if(obj1.type == 1 && obj2.type == 1)
      return false;
    let dx = obj1.model.x - obj2.model.x;
    let dy = obj1.model.y - obj2.model.y;
    let dis = dx * dx + dy * dy;
    let sumr = obj1.r * obj1.model.scaleX + obj2.r * obj2.model.scaleX;
    return dis <= sumr * sumr;
  }

  function checkCollision(obj1, obj2) { // 碰撞后修改参数

    res = isCollided(obj1, obj2);
    if(res == false)
      return false;

    obj1.healthDrop(obj2.bodyDamage);
    obj2.healthDrop(obj1.bodyDamage);
    if(obj2.healthPoint <= 0)
    {
      if(obj1.type == 0)       // tank
        obj1.experienceUp(obj2.bonus);
      else if(obj1.type == 1)  // bullet
        tankMap[obj1.belong].experienceUp(obj2.bonus);
    }
    if(obj1.healthPoint <= 0)
    {
      if(obj2.type == 0)       // tank
        obj2.experienceUp(obj1.bonus);
      else if(obj2.type == 1)  // bullet
        tankMap[obj2.belong].experienceUp(obj1.bonus);
    }

    if(obj1 == maintk || obj2 == maintk) {
      // TODO: maintk 碰撞动画 & 其他参数修改
      if(banKeyBoard) return;
      // console.log('maintk collide!');
      let destX = maintk.model.x - maintk.xMoveSpeed * 10;
      let destY = maintk.model.y - maintk.yMoveSpeed * 10;
      banKeyboard = true       // 禁止使用键盘移动
      socket.emit('collide', ['collide', this.armsId, destX, destY]);
      createjs.Tween.get(maintk.model).to({x: destX, y: destY}, 500).call(handleComplete);
      function handleComplete() {banKeyboard = false;}
    }

    return true;
  }


  // BaseModel part
  function BaseModel (modelX, modelY, armsId = 0) {
    this.model = new createjs.Container();
    this.heads = new createjs.Container();
    this.headOuterRadius = [];
    this.body = new createjs.Shape();
    this.health = new createjs.Shape();
    this.status = new createjs.Text();

    this.type = 0;
    this.model.x = modelX;
    this.model.y = modelY;
    this.model.scaleX = 0.8;
    this.model.scaleY = 0.8;
    this.armsId = armsId;
    this.bodyStrokeColor = '#000';
    this.bodyFillColor = '#000';
    this.r = 0;
    this.name = 'Tank';

    this.setBodyColor('', '', 1);
    this.decorate(this.armsId);
    this.model.addChild(this.heads);
    this.model.addChild(this.body);
    this.model.addChild(this.health);
    this.model.addChild(this.status);
  }

  BaseModel.prototype.setBodyColor = function (strokeColor, fillColor, builtInColorStyle = 0) {
    switch(builtInColorStyle) {
      case 1: this.bodyStrokeColor = '#1f90ae', this.bodyFillColor = '#00b2e1'; break;
      case 2: this.bodyStrokeColor = '#bfae4e', this.bodyFillColor = '#ffe869'; break;
      case 3: this.bodyStrokeColor = '#c28081', this.bodyFillColor = '#fc7677'; break;
      case 4: this.bodyStrokeColor = '#5869bd', this.bodyFillColor = '#768dfc'; break;
      case 5: this.bodyStrokeColor = '#b43a3f', this.bodyFillColor = '#f14e54'; break;
      default: this.bodyStrokeColor = strokeColor, this.bodyFillColor = fillColor;
    }
  }

  BaseModel.prototype.decorate = function (armsId) {
    this.headDecorate((armsId >> 4) & 63);
    this.bodyDecorate(armsId & 3);
    if(((armsId >> 2) & 3) != 1) {
      // 不是子弹，画血条
      this.health.graphics.clear().f('#555555').rr(-30, this.r  + 10, 60, 8, 4);
      this.health.graphics.f('#85e37d').rr(-28, this.r  + 12, 56, 4, 2);
    }
    if(((armsId >> 2) & 3) == 0) {
      // 是坦克，画状态 [未启用]
      this.status.text = this.name;
      this.status.font = 'bold 20px Ubuntu';
      this.status.color = '#000000';
      this.status.x = 0;
      this.status.y = -this.r - 30;
      this.status.textAlign = 'center';
      this.status.visible = false;
    }
    this.setHealthCond(1.0);
    this.armsId = armsId;
  }

  BaseModel.prototype.headDecorate = function (headId) {
    headShapes = [];
    this.headOuterRadius.length = 0;

    switch(headId) {
      case 0: // 无炮管
        break;
      case 1: // 矩形炮管 * 1
        headShapes.push(new createjs.Shape());
        this.headOuterRadius.push(60);
        headShapes[0].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 60, 30);
        break;
      case 2: // 矩形长炮管 * 1
        headShapes.push(new createjs.Shape());
        this.headOuterRadius.push(70);
        headShapes[0].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 70, 30);
        break;
      case 3: // 矩形炮管 * 1 + 矩形短炮管 * 1
        headShapes.push(new createjs.Shape(), new createjs.Shape());
        this.headOuterRadius.push(60, 45);
        headShapes[0].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 60, 30);
        headShapes[1].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 45, 30);
        headShapes[1].rotation = 180;
        break;
      case 4: // 梯形炮管 * 1
        headShapes.push(new createjs.Shape());
        this.headOuterRadius.push(60);
        headShapes[0].graphics.ss(4).s('#727272').f('#999999');
        headShapes[0].graphics.mt(-30, 0).lt(60, -20).mt(58, -20).lt(58, 20).mt(60, 20).lt(-30, 0);
        break;
      case 5: // 双发炮管 * 1
        headShapes.push(new createjs.Shape(), new createjs.Shape());
        this.headOuterRadius.push(60, 60);
        headShapes[0].graphics.ss(4).s('#727272').f('#999999').dr(0, -20, 60, 17);
        headShapes[1].graphics.ss(4).s('#727272').f('#999999').dr(0, 3, 60, 17);
        break;
      case 6: // 三发炮管 * 1
        headShapes.push(new createjs.Shape(), new createjs.Shape(), new createjs.Shape());
        this.headOuterRadius.push(50, 50, 50);
        headShapes[0].graphics.ss(4).s('#727272').f('#999999').dr(0, -10, 50, 20);
        headShapes[1].graphics.ss(4).s('#727272').f('#999999').dr(0, -10, 50, 20);
        headShapes[1].rotation = 315;
        headShapes[2].graphics.ss(4).s('#727272').f('#999999').dr(0, -10, 50, 20);
        headShapes[2].rotation = 45;
        break;
      case 7: // 矩形炮管 * 4
        headShapes.push(new createjs.Shape(), new createjs.Shape(), new createjs.Shape(), new createjs.Shape());
        this.headOuterRadius.push(60, 60, 60, 60);
        headShapes[0].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 60, 30);
        headShapes[1].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 60, 30);
        headShapes[1].rotation = 90;
        headShapes[2].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 60, 30);
        headShapes[2].rotation = 180;
        headShapes[3].graphics.ss(4).s('#727272').f('#999999').dr(0, -15, 60, 30);
        headShapes[3].rotation = 270;
        break;
      default:
        alert('How can you reach here H?');
        break;
    }
    this.heads.removeAllChildren();
    for(let i = 0; i < headShapes.length; i++)
      this.heads.addChild(headShapes[i]);
    this.heads.scaleX = this.heads.scaleY = 1;
  }

  BaseModel.prototype.bodyDecorate = function (bodyId) {
    this.body.graphics.clear().ss(4).s(this.bodyStrokeColor).f(this.bodyFillColor);
    switch(bodyId) {
      case 0: // 圆形底座
        this.body.graphics.dc(0, 0, 30);
        this.r = 30; break;
      case 1: // 方形底座
        this.body.graphics.dr(-20, -20, 40, 40);
        this.r = 20; break;
      case 2: // 正三角形
        this.body.graphics.dp(0, 0, 20, 3, 0, 0);
        this.r = 10; break;
      case 3: // 正五边形
        this.body.graphics.dp(0, 0, 40, 5, 0, 0);
        this.r = 32.4; break;
      default:
        alert('How can you reach here B?'); break;
    }
    this.body.scaleX = this.body.scaleY = 1;
  }

  BaseModel.prototype.setHealthCond = function (ratio) {
    if(ratio < 0.0 || ratio > 1.0) return;
    if(((this.armsId >> 2) & 3) != 1) {
      // 不是子弹，画血条
      this.health.graphics.clear().f('#555555').rr(-30, this.r  + 10, 60, 8, 4);
      this.health.graphics.f('#85e37d').rr(-28, this.r  + 12, 56 * ratio, 4, 2);
    }
  }

  // GeneralModel part
  function GeneralModel (modelX, modelY, armsId) {
    BaseModel.call(this, modelX, modelY, armsId);
    this.type = 0;
    this.bonus = 800;
    this.healthPoint = 100;
    this.maxHealthPoint = 100;
    this.xMoveSpeed = 0;
    this.yMoveSpeed = 0;
    this.maxMoveSpeed = 5;
    this.bodyDamage = 30;

    this.nearTank = [];
    this.nearCreep = [];
    this.nearBullet = [];
  }

  GeneralModel.prototype = new BaseModel();
  GeneralModel.prototype.constructor = GeneralModel;

  GeneralModel.prototype.healthDrop = function(damage) {
    this.healthPoint -= damage;
    if(this.healthPoint < 0)
      this.healthPoint = 0;
    socket.emit('HPdrop', ['HPdrop', this.armsId, this.healthPoint]);
    this.setHealthCond(this.healthPoint / this.maxHealthPoint);
    if(this.healthPoint <= 0) {
      createjs.Tween.removeTweens(this.model);
      stage.removeChild(this.model);
      // console.log('send KILL info');
      socket.emit('killed', ['killed', this.armsId]);
      findDelete(this.armsId);
    }
  }

  GeneralModel.prototype.getNearTank = function() {
    this.nearTank = [];
    for(let i = 0; i < tankList.length; i++)
      if(isNear(this, tankList[i]))
        this.nearTank.push(tankList[i].armsId);
  }

  GeneralModel.prototype.getNearCreep = function() {
    this.nearCreep = [];
    for(let i = 0; i < creepList.length; i++)
      if(isNear(this, creepList[i]))
        this.nearCreep.push(creepList[i].armsId);
  }

  GeneralModel.prototype.getNearBullet = function() {
    this.nearBullet = [];
    for(let i = 0; i < bulletList.length; i++)
      if(isNear(this, bulletList[i]))
        this.nearBullet.push(bulletList[i].armsId);
  }

  GeneralModel.prototype.packageInfo = function() {
    // TODO: package infomation
    return this;
  }

  // Tank part
  function Tank (modelX, modelY, armsId = 0) {
    GeneralModel.call(this, modelX, modelY, armsId);
    this.type = 0;
    this.score = 0;
    this.level = 1;
    this.experience = 0;
    this.bulletReloadInterval = 1000;
    this.maxBulletSpeed = 5;
    this.bulletDamage = 30;
    this.regenerationRate = 10;
  }

  Tank.prototype = new GeneralModel();
  Tank.prototype.constructor = Tank;

  Tank.prototype.levelUp = function() {
    if(this.level == MAX_TANK_GRADE)
      return;
    this.level ++;
    Hstage.removeChild(bm.model);
    Hstage.addChild(bm.model);
    bm.clickNum ++;
    bm.slipIn();
    if(this.level == 2) {   // 第一次坦克升级
      Hstage.removeChild(updmenu.model);
      Hstage.addChild(updmenu.model);
      updmenu.slipIn();
    }
  }

  Tank.prototype.experienceUp = function(exp) {
    this.score += exp;
    if(this.level == MAX_TANK_GRADE)
      return;
    this.experience += exp;
    if(this.experience >= levelUpThreshold[this.level]) {
      this.experience -= levelUpThreshold[this.level];
      this.levelUp();
    }
    iw.animateExp(this.level, this.experience / levelUpThreshold[this.level]);
    iw.setScore(this.score);
  }

  Tank.prototype.tankMove = function() {
    if(this.healthPoint <= 0)
      return;
    this.xMoveSpeed = 0;
    this.yMoveSpeed = 0;
    if(banKeyBoard == true)
      return;
    if(KEYBOARD_CONDITION & 8) this.yMoveSpeed = -this.maxMoveSpeed;
    if(KEYBOARD_CONDITION & 4) this.yMoveSpeed = this.maxMoveSpeed;
    if(KEYBOARD_CONDITION & 2) this.xMoveSpeed = -this.maxMoveSpeed;
    if(KEYBOARD_CONDITION & 1) this.xMoveSpeed = this.maxMoveSpeed;

    if(this.xMoveSpeed != 0 && this.yMoveSpeed != 0) {
      this.xMoveSpeed *= Math.sqrt(2) / 2;
      this.yMoveSpeed *= Math.sqrt(2) / 2;
    }

    this.xMoveSpeed = this.xMoveSpeed * 30 / FRAME_RATE;
    this.yMoveSpeed = this.yMoveSpeed * 30 / FRAME_RATE;

    this.model.x += this.xMoveSpeed;
    this.model.y += this.yMoveSpeed;
    if(this.model.x > CANVAS_RIGHT) this.model.x = CANVAS_RIGHT;
    if(this.model.x < CANVAS_LEFT) this.model.x = CANVAS_LEFT;
    if(this.model.y > CANVAS_TOP) this.model.y = CANVAS_TOP;
    if(this.model.y < CANVAS_BOTTOM) this.model.y = CANVAS_BOTTOM;

    socket.emit('move', ['move', this.armsId, this.model.x, this.model.y]);

    if(!banKeyBoard) {
      for (let i = 0; i < tankList.length; i++) {
        if (checkCollision(this, tankList[i]) == true)
          return;
      }
      for (let i = 0; i < creepList.length; i++) {
        if (checkCollision(this, creepList[i]) == true)
          return;
      }
    }
  }

  Tank.prototype.fireBullet = function() {
    if(this.healthPoint <= 0) return;
    for(let i = 0; i < this.heads.numChildren; i++) {
      let angle = tools.deg2Rad(this.heads.rotation + this.heads.getChildAt(i).rotation)
      let bulletX = this.model.x + this.headOuterRadius[i] * Math.cos(angle);
      let bulletY = this.model.y + this.headOuterRadius[i] * Math.sin(angle);
      // let bullet = new Bullet(bulletX, bulletY, armsId = 4, this);  // 01 00
      let xMoveSpeed = this.maxBulletSpeed * Math.cos(angle);
      let yMoveSpeed = this.maxBulletSpeed * Math.sin(angle);
      // bulletList.push(bullet);
      // bulletMap[bullet.armsId] = bullet;
      // stage.addChild(bullet.model);
      // bullet.bulletMove();
      socket.emit('fire', ['fire', bulletX, bulletY, 0, this.armsId, xMoveSpeed, yMoveSpeed]);
    }
  }


  // Bullet part
  function Bullet (modelX, modelY, armsId = 4, belong) {
    GeneralModel.call(this, modelX, modelY, armsId);
    this.type = 1;
    this.healthPoint = 1;
    this.belong = belong;
    this.model.scaleX = 0.4;
    this.model.scaleY = 0.4;
    this.bodyDamage = tankMap[belong].bulletDamage;
    this.bonus = 0;
  }

  Bullet.prototype = new GeneralModel();
  Bullet.prototype.constructor = Bullet;

  Bullet.prototype.bulletMove = function() {
    let xTime, yTime, This = this;

    if(this.xMoveSpeed > 0) xTime = (CANVAS_RIGHT - this.model.x) / this.xMoveSpeed;
    else if(this.xMoveSpeed < 0) xTime = (CANVAS_LEFT - this.model.x) / this.xMoveSpeed;
    if(this.yMoveSpeed > 0) yTime = (CANVAS_TOP - this.model.y) / this.yMoveSpeed;
    else if(this.yMoveSpeed < 0) yTime = (CANVAS_BOTTOM - this.model.y) / this.yMoveSpeed;
    let time = Math.min(xTime, yTime);

    let destX = this.model.x + this.xMoveSpeed * time;
    let destY = this.model.y + this.yMoveSpeed * time;

    if(this.belong == maintk.armsId)
      createjs.Tween.get(this.model).to({x: destX, y: destY}, 30 * time).call(handleComplete).
      addEventListener('change', handleChange);
    else
      createjs.Tween.get(this.model).to({x: destX, y: destY}, 30 * time).call(handleComplete);

    function handleChange(event) {
      for(let i = 0; i < tankList.length; i++) {
        if(tankList[i] != maintk && checkCollision(This, tankList[i]) == true)
          return;
      }
      for(let i = 0; i < creepList.length; i++) {
        if(checkCollision(This, creepList[i]) == true)
          return;
      }
    }

    function handleComplete() {
      stage.removeChild(This.model);
      for(let i = 0; i < bulletList.length; i++)
        if(This == bulletList[i]) {
          bulletList.splice(i, 1);
          break;
        }
    };
  }


  // Creep part
  function Creep (modelX, modelY, armsId = 0) {
    GeneralModel.call(this, modelX, modelY, armsId);
    this.type = 2;
  }

  Creep.prototype = new GeneralModel();
  Creep.prototype.constructor = Creep;


  // KeyBoard Event & Mouse Event
  document.onkeydown = function(ev) {
    var kEvent = ev || window.event;
    if(kEvent.keyCode == KEYBOARD_UP)
      KEYBOARD_CONDITION |= 8;
    else if(kEvent.keyCode == KEYBOARD_DOWN)
      KEYBOARD_CONDITION |= 4;
    else if(kEvent.keyCode == KEYBOARD_LEFT)
      KEYBOARD_CONDITION |= 2;
    else if(kEvent.keyCode == KEYBOARD_RIGHT)
      KEYBOARD_CONDITION |= 1;
  }

  document.onkeyup = function(ev) {
    var kEvent = ev || window.event;
    if(kEvent.keyCode == KEYBOARD_UP)
      KEYBOARD_CONDITION &= 7;
    else if(kEvent.keyCode == KEYBOARD_DOWN)
      KEYBOARD_CONDITION &= 11;
    else if(kEvent.keyCode == KEYBOARD_LEFT)
      KEYBOARD_CONDITION &= 13;
    else if(kEvent.keyCode == KEYBOARD_RIGHT)
      KEYBOARD_CONDITION &= 14;
  }

  document.onmousemove = function(ev) {
    var mEvent = ev || window.event;
    let x = Math.round(mEvent.clientX - cvsBox.left - stage.x);
    let y = Math.round(mEvent.clientY - cvsBox.top - stage.y);
    maintk.heads.rotation = tools.vec2Deg(x - maintk.model.x, y - maintk.model.y)
    socket.emit('turn', ['turn', maintk.armsId, maintk.heads.rotation]);
    stage.update();
  }

  var preTime = new Date();
  document.onmousedown = function(ev) {
    var curTime = new Date();
    if(curTime - preTime > maintk.bulletReloadInterval) {
      maintk.fireBullet();
      preTime = curTime;
    }
  }

  // Ticker Event
  function autoHealthRegeneration() {
    if(!maintk) return;
    maintk.healthPoint += maintk.regenerationRate;
    maintk.healthPoint = Math.min(maintk.healthPoint, maintk.maxHealthPoint);
    socket.emit('HPdrop', ['HPdrop', maintk.armsId, maintk.healthPoint]);
  }
  setInterval(autoHealthRegeneration, 3000);

  // Handle Server Message
  function find(id) {
    for(let i = 0; i < tankList.length; i++)
      if(tankList[i].armsId == id)
        return tankList[i];
    for(let i = 0; i < bulletList.length; i++)
      if(bulletList[i].armsId == id)
        return bulletList[i];
    for(let i = 0; i < creepList.length; i++)
      if(creepList[i].armsId == id)
        return creepList[i];
    return 0;
    // alert('Find Nothing');
  }

  function findDelete(id) {
    for(let i = 0; i < tankList.length; i++)
      if(id == tankList[i].armsId) {
        tankList.splice(i, 1);
        return;
      }
    for(let i = 0; i < creepList.length; i++)
      if(id == creepList[i].armsId) {
        creepList.splice(i, 1);
        return;
      }
    for(let i = 0; i < bulletList.length; i++)
      if(id == bulletList[i].armsId) {
        bulletList.splice(i, 1);
        return;
      }
  }

  function serverMessage(data) {
    if (serverEvent[data[0]])
      serverEvent[data[0]](data);
  }

  var maintk;

  var serverEvent = {
    control: function(data) {
      console.log('control: maintk id = ', data[1]);
      for(let i = 0; i < tankList.length; i++)
        if(tankList[i].armsId == data[1])
          maintk = tankList[i];
      if(!maintk) alert('ERROR: NO TANK!!!');
      createjs.Ticker.addEventListener('tick', function() {
        stage.x = (BODY_WIDTH >> 1) - maintk.model.x;
        stage.y = (BODY_HEIGHT >> 1) - maintk.model.y;
        if(maintk)
          maintk.tankMove();
        stage.update();
      });
    },
    move: function(data) {
      for(let i = 0; i < tankList.length; i++)
        if(tankList[i].armsId == data[1]) {
          tankList[i].model.x = data[2];
          tankList[i].model.y = data[3];
        }
    },
    turn: function(data) {
      for(let i = 0; i < tankList.length; i++)
        if(tankList[i].armsId == data[1])
          tankList[i].heads.rotation = data[2];
    },
    fire: function(data) {
      // ['fire', bulletX, bulletY, bulletId, tankId, xMoveSpeed, yMoveSpeed]
      // rule: who fire the bullet, who check the collision.
      console.log('bulletId = ', data[3]);
      let bullet = new Bullet(data[1], data[2], data[3], data[4]);
      bullet.xMoveSpeed = data[5];
      bullet.yMoveSpeed = data[6];
      bulletList.push(bullet);
      bulletMap[data[3]] = bullet;
      stage.addChild(bullet.model);
      bullet.bulletMove();
    },
    addTank: function(data) {
      let tank = new Tank(data[2], data[3], data[1]);
      tank.healthPoint = data[4];
      tank.maxHealthPoint = data[5];
      tank.setHealthCond(data[4] / data[5]);
      tankList.push(tank);
      tankMap[tank.armsId] = tank;
      stage.addChild(tank.model);
    },
    addCreep: function(data) {
      let creep = new Creep(data[2], data[3], data[1]);
      creep.setBodyColor('', '', Math.floor(Math.random() * 4 + 2));
      creep.decorate(creep.armsId);
      creep.healthPoint = data[4];
      creep.maxHealthPoint = data[5];
      creep.setHealthCond(data[4] / data[5]);
      creepList.push(creep);
      creepMap[creep.armsId] = creep;
      stage.addChild(creep.model);
    },
    killed: function(data) {
      let obj = 0;
      console.log('dead id = ', data[1]);
      for(let i = 0; i < tankList.length; i++)
        if(tankList[i].armsId == data[1]) {
          obj = tankList[i];
          tankList.splice(i, 1);
          break;
        }
      for(let i = 0; i < creepList.length; i++)
        if(creepList[i].armsId == data[1]) {
          obj = creepList[i];
          creepList.splice(i, 1);
          break;
        }
      for(let i = 0; i < bulletList.length; i++)
        if(bulletList[i].armsId == data[1]) {
          obj = bulletList[i];
          bulletList.splice(i, 1);
          break;
        }
      if(!obj) return;
      console.log(obj, ' is killed.')
      stage.removeChild(obj.model);
      createjs.Tween.removeTweens(obj.model);
      // if(obj.armsId == maintk.armsId)
      //   alert('YOU DIE');
    },
    HPdrop: function(data) {
      let obj = find(data[1]);
      if(!obj) return;
      obj.healthPoint = data[2];
      obj.setHealthCond(obj.healthPoint / obj.maxHealthPoint);
    },
    upgrade: function(data) {
      let tk = find(data[1]);
      switch(data[2])
      {
        case 0: (tk.regenerationRate += 1); break;
        case 1: (tk.maxHealthPoint += 20); (tk.healthPoint += 20);
          tk.setHealthCond(tk.healthPoint/tk.maxHealthPoint); break;
        case 2: (tk.bodyDamage += 10); break;
        case 3: (tk.maxBulletSpeed += 1); break;
        case 4: (tk.bulletDamage += 10); break;
        case 5: (tk.bulletReloadInterval -= 80); break;
        case 6: (tk.maxMoveSpeed += 1); break;
        case 7: tk.armsId = (tk.armsId & 0xfc00) | data[3];
                tankMap[tk.armsId] = tk;
                tk.decorate(tk.armsId);
                tk.setHealthCond(tk.healthPoint / tk.maxHealthPoint);
                break;
        default: break;
      }
    }
  };

  // 实例
  socket.on('addTank', serverMessage);
  socket.on('addCreep', serverMessage);
  socket.on('control', serverMessage);
  socket.on('upgrade', serverMessage);
  socket.on('killed', serverMessage);
  socket.on('HPdrop', serverMessage);
  socket.on('move', serverMessage);
  socket.on('turn', serverMessage);
  socket.on('fire', serverMessage);

  Hcanvas.width = BODY_WIDTH;
  Hcanvas.height = BODY_HEIGHT;
  var Hstage = new createjs.Stage('Hcanvas');
  var bm = new BoostMenu(0, BODY_HEIGHT - 200);
  var minimap = new MiniMap(BODY_WIDTH - 200, BODY_HEIGHT - 200, 2000, './images/map_172x172.png');
  var iw = new InfoBar(BODY_WIDTH >> 1, BODY_HEIGHT - 40);
  var updmenu = new UpgradeMenu(10, 10);
  var tankX = 500;
  var tankY = 500;
  var tic = 0;
  Hstage.addChild(minimap.model, iw.model);
  createjs.Ticker.framerate = FRAME_RATE;
  createjs.Ticker.addEventListener('tick', function() {
    if(!maintk) return;
    minimap.animateCoord(maintk.model.x, maintk.model.y);
    Hstage.update();
  });
  iw.init(pageVueData.nickname, 'Tank', 0, 1, 0);
  updmenu.setItemOnShow(0, 0);
  updmenu.setItemOnShow(1, 32);
  updmenu.setItemOnShow(2, 80);
  updmenu.setItemOnShow(3, 96);

</script>
</body>
</html>